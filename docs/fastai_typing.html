---
title: fastai_typing
keywords: fastai
sidebar: home_sidebar
tags: 
summary: "Type annotations names"
---

<div class="container" id="notebook-container">
    
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Type-abbreviations">Type abbreviations<a class="anchor-link" href="#Type-abbreviations">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The code and docs sometimes use <em>type abbreviations</em> to avoid type signatures getting unwieldy. Here's a list of all abbreviations for composite types for convenient access.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="From-core">From <code>core</code><a class="anchor-link" href="#From-core">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li><code>AnnealFunc</code> = <code>Callable</code>[[<code>Number</code>,<code>Number</code>,<code>float</code>], <code>Number</code>]</li>
<li><code>ArgStar</code> = <code>Collection</code>[<code>Any</code>]</li>
<li><code>BatchSamples</code> = <code>Collection</code>[<code>Tuple</code>[<code>Collection</code>[<code>int</code>], <code>int</code>]]</li>
<li><code>Classes</code> = <code>Collection</code>[<code>Any</code>]</li>
<li><code>FilePathList</code> = <code>Collection</code>[<code>Path</code>]</li>
<li><code>Floats</code> = <code>Union</code>[<code>float</code>, <code>Collection</code>[<code>float</code>]]</li>
<li><code>ImgLabels</code> = <code>Collection</code>[<code>ImgLabel</code>]</li>
<li><code>KeyFunc</code> = <code>Callable</code>[[<code>int</code>], <code>int</code>]</li>
<li><code>KWArgs</code> = <code>Dict</code>[<code>str</code>,<code>Any</code>]</li>
<li><code>ListOrItem</code> = <code>Union</code>[<code>Collection</code>[<code>Any</code>],<code>int</code>,<code>float</code>,<code>str</code>]</li>
<li><code>ListRules</code> = <code>Collection</code>[<code>Callable</code>[[<code>str</code>],<code>str</code>]]</li>
<li><code>ListSizes</code> = <code>Collection</code>[<code>Tuple</code>[<code>int</code>,<code>int</code>]]</li>
<li><code>NPArrayableList</code> = <code>Collection</code>[<code>Union</code>[<code>np</code>.<code>ndarray</code>, <code>list</code>]]</li>
<li><code>NPArrayList</code> = <code>Collection</code>[<code>np</code>.<code>ndarray</code>]</li>
<li><code>OptDataFrame</code> = <code>Optional</code>[<code>DataFrame</code>]</li>
<li><code>OptListOrItem</code> = <code>Optional</code>[<code>ListOrItem</code>]</li>
<li><code>OptRange</code> = <code>Optional</code>[<code>Tuple</code>[<code>float</code>,<code>float</code>]]</li>
<li><code>OptStrTuple</code> = <code>Optional</code>[<code>Tuple</code>[<code>str</code>,<code>str</code>]]</li>
<li><code>OptStats</code> = <code>Optional</code>[<code>Tuple</code>[<code>np</code>.<code>ndarray</code>, <code>np</code>.<code>ndarray</code>]]</li>
<li><code>PathOrStr</code> = <code>Union</code>[<code>Path</code>,<code>str</code>]</li>
<li><code>PBar</code> = <code>Union</code>[<code>MasterBar</code>, <code>ProgressBar</code>]</li>
<li><code>Point</code>=<code>Tuple</code>[<code>float</code>,<code>float</code>]</li>
<li><code>Points</code>=<code>Collection</code>[<code>Point</code>]</li>
<li><code>Sizes</code> = <code>List</code>[<code>List</code>[<code>int</code>]]</li>
<li><code>SplitArrayList</code> = <code>List</code>[<code>Tuple</code>[<code>np</code>.<code>ndarray</code>,<code>np</code>.<code>ndarray</code>]]</li>
<li><code>StartOptEnd</code>=<code>Union</code>[<code>float</code>,<code>Tuple</code>[<code>float</code>,<code>float</code>]]</li>
<li><code>StrList</code> = <code>Collection</code>[<code>str</code>]</li>
<li><code>Tokens</code> = <code>Collection</code>[<code>Collection</code>[<code>str</code>]]</li>
<li><code>OptStrList</code> = <code>Optional</code>[<code>StrList</code>]</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="From-torch_core">From <code>torch_core</code><a class="anchor-link" href="#From-torch_core">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li><code>BoolOrTensor</code> = <code>Union</code>[<code>bool</code>,<code>Tensor</code>]</li>
<li><code>FloatOrTensor</code> = <code>Union</code>[<code>float</code>,<code>Tensor</code>]</li>
<li><code>IntOrTensor</code> = <code>Union</code>[<code>int</code>,<code>Tensor</code>]</li>
<li><code>ItemsList</code> = <code>Collection</code>[<code>Union</code>[<code>Tensor</code>,<code>ItemBase</code>,'<code>ItemsList</code>',<code>float</code>,<code>int</code>]]</li>
<li><code>LambdaFunc</code> = <code>Callable</code>[[<code>Tensor</code>],<code>Tensor</code>]</li>
<li><code>LayerFunc</code> = <code>Callable</code>[`nn<code>.</code>Module<code>],</code>None`]</li>
<li><code>Model</code> = <code>nn</code>.<code>Module</code></li>
<li><code>ModuleList</code> = <code>Collection</code>`nn<code>.</code>Module`]</li>
<li><code>OptOptimizer</code> = <code>Optional</code>`optim<code>.</code>Optimizer`]</li>
<li><code>ParamList</code> = <code>Collection</code>`nn<code>.</code>Parameter`]</li>
<li><code>Rank0Tensor</code> = <code>NewType</code>('<code>OneEltTensor</code>', <code>Tensor</code>)</li>
<li><code>SplitFunc</code> = <code>Callable</code>[`Model<code>],</code>List<code>\</code>Model`]]</li>
<li><code>SplitFuncOrIdxList</code> = <code>Union</code>[<code>Callable</code>, <code>Collection</code>[<code>ModuleList</code>]]</li>
<li><code>TensorOrNumber</code> = <code>Union</code>[<code>Tensor</code>,<code>Number</code>]</li>
<li><code>TensorOrNumList</code> = <code>Collection</code>[<code>TensorOrNumber</code>]</li>
<li><code>TensorImageSize</code> = <code>Tuple</code>[<code>int</code>,<code>int</code>,<code>int</code>]</li>
<li><code>Tensors</code> = <code>Union</code>[<code>Tensor</code>, <code>Collection</code>['<code>Tensors</code>']]</li>
<li><code>Weights</code> = <code>Dict</code>[<code>str</code>,<code>Tensor</code>]</li>
<li><code>AffineFunc</code> = <code>Callable</code>[[<code>KWArgs</code>], <code>AffineMatrix</code>]</li>
<li><code>HookFunc</code> = <code>Callable</code>[`Model<code>,</code>Tensors<code>,</code>Tensors<code>],</code>Any`]</li>
<li><code>LogitTensorImage</code> = <code>TensorImage</code></li>
<li><code>LossFunction</code> = <code>Callable</code>[[<code>Tensor</code>, <code>Tensor</code>], <code>Rank0Tensor</code>]</li>
<li><code>MetricFunc</code> = <code>Callable</code>[[<code>Tensor</code>,<code>Tensor</code>],<code>TensorOrNumber</code>]</li>
<li><code>MetricFuncList</code> = <code>Collection</code>[<code>MetricFunc</code>]</li>
<li><code>MetricsList</code> = <code>Collection</code>[<code>TensorOrNumber</code>]</li>
<li><code>OptLossFunc</code> = <code>Optional</code>[<code>LossFunction</code>]</li>
<li><code>OptMetrics</code> = <code>Optional</code>[<code>MetricsList</code>]</li>
<li><code>OptSplitFunc</code> = <code>Optional</code>[<code>SplitFunc</code>]</li>
<li><code>PixelFunc</code> = <code>Callable</code>[[<code>TensorImage</code>, <code>ArgStar</code>, <code>KWArgs</code>], <code>TensorImage</code>]</li>
<li><code>CoordFunc</code> = <code>Callable</code>[`FlowField<code>,</code>TensorImageSize<code>,</code>ArgStar<code>,</code>KWArgs<code>],</code>LogitTensorImage`]</li>
<li><code>LightingFunc</code> = <code>Callable</code>[[<code>LogitTensorImage</code>, <code>ArgStar</code>, <code>KWArgs</code>], <code>LogitTensorImage</code>]</li>
</ul>

</div>
</div>
</div>
</div>
 

